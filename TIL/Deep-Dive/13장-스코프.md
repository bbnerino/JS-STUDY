# 13. 스코프

# 13.1 스코프란?

스코프란 식별자가 유효한 유효범위를 뜻한다.
모든 식별자는 자신이 선언된 위체에 의해 다른 코드가 자신을 참조할 수 있는 유효 범위가 결정된다.

변수는 자신이 선언된 위체에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 잇는 범위가 결정된다.

var 와 (let,const) 로 선언한 변수의 스코프는 다르게 동작한다.

## 렉시컬 환경

"코드가 어디서 실행되며, 주변에 어떤 코드가 있는지"
코드의 문맥은 렉시컬 환경에서 이루어진다.
이것을 구현한 것이 **실행 컨텍스트**이다
(구성하는 환경 정보들을 모아 사전처럼 구성한 객체)

```js
const a = 5;
const b = () => {
  const a = 3; // 에러가 안난다.
};
```

스코프라는 개념이 없었다면 같은 이름의 변수는 충돌이 났을텐데,
스코프가 있기 때문에 두개는 다른 별개의 변수이다.

스코프는 네임스페이스이다. (이름 공간)

> var 로 선언한 변수는 같은 스코프 내에서 중복 선언이 허용된다.
> => 변수값이 재할당 되어, 부작용을 발생시킨다.

# 13.2 스코프의 종류

코드는 전역과 지역으로 구분된다.

변수는 자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정된다.

- 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고,
- 지역에서 선언되면 지역 변수이다.

### 지역과 지역 스코프

지역은 함수 몸체 내부를 뜻하고 지역 스코프를 만든다.
지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.

# 13.3 스코프 체인

JS 엔진이 함수 내부에서 변수를 호출하면, 동일 변수명이 있을 때 전역변수가 아닌 지역변수를 참조한다.

함수는 중첩될 수 있고, 따라서 스코프도 중첩이 가능하다.
스코프가 함수의 중첩에 의해 계층적 구조를 갖는다.

모든 스코프는 계층적 구조로 연결되며, 최상위 스코프는 전역 스코프이다.
스코프가 계층으로 연결된 것을 **스코프 체인**이라고 한다.

변수를 참조할 때, JS엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여, 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

JS엔진은 코드를 실행하기 앞서, **렉시컬 환경**을 실제로 생성한다.
변수 선언이 실행되면, 변수 식별자가 이 렉시컬 환경에 키로 등록되고, 변수 할당이 이뤄지면 값을 변경한다.

#### 렉시컬 환경

스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것
전역 렉시컬 환경은 바로 생성되고,
함수의 렉시컬 환경은 함수가 호출되면 생성된다.

# 13.4 함수 레벨 스코프

코드 블록이 아닌 **함수**에 의해서만 지역 스코프가 생성된다.

코드 블록 : if for while...

C 자바는 모든 코드 블록이 지역 스코프를 만든다 (블록 레벨 스코프)

하지만 var로 선언된 변수는 오로지 함수의 블록 만을 지역 스코프로 인정한다. (함수 레벨 스코프)

```js
var a = 1
if (true){
  var a = 10;// 재할당 해버리기
}
a ? 10
```

var 로 선언된 함수는 함수만을 지역 스코프로 인정한다.
함수 밖에서 var 키워드로 선언된 변수는 모드 전역 변수이다.

let 과 const 를 이용하면, 블록 레벨 스코프를 지원하기 때문에, 안전하게 사용 가능하다.

# 렉시컬 스코프

다음 함수의 결과를 예상해보자

```js
var x = 1;
function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}
foo();
bar();
```

함수의 스코프는 두가지가 예상이 가능하다.

1. 함수를 어디서 호출했냐에 따라 상위 스코프를 결정한다.(동적 스코프)

2. 함수를 어디서 정의했는지에 따라 상위 스코프를 따라간다.(렉시컬 스코프,정적 스코프)

JS 에서는 함수를 선언한 환경에 따라 상위 스코프를 결정한다.
함수가 호출된 위치는 상위 스코프 결정에 영향을 미치지 않는다.
**함수가 정의된 스코프**가 상위 스코프이다
